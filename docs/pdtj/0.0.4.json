"{'easyT': {'type': 'directory', 'platforms.py': {'type': 'python file', 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}}, 'rates.py': {'type': 'python file', 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'get_rates': {'introduction': 'The function get_rates is used to select which rates will be used taking in consideration the platform.\\n\\nThe Rates class is responsible to retrieve a certain amount of previous data.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'platform': {'description': '\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want to retrieve previous data.\\n\\n    timeframe (TimeFrame):\\n        The timeframe you want information, like 1 minute, 5 minute, 1 week.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'count': {'description': '\\n        It is the amount of information in the past you want. If your time frame is 5 minutes and your count is 4,\\n        it will return 4 values containing time, open, high, low, close, tick_volume information of this past 4\\n        candlesticks.\\n\\n', 'type': <class 'int'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n        It returns the right class that will be used or an error message in case it was not found'}}, 'file_generator.py': {'type': 'python file', 'get_arguments': {'introduction': ''}, 'main': {'introduction': ''}}, 'manager.py': {'type': 'python file', 'ClassNotInvoked': {'introduction': 'Raise this error when the class is called but not invoked first!'}, 'Manager': {'introduction': '', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}, '_supervise_trading_time': {'introduction': 'It checks the trading time window to see if the algotrading is allowed to trade or if it should close\\nopened position.\\n\\nThere is no need to inform this information, but keep in mid the Algotrading might not work as expected.\\n\\n', 'returns': '\\n    It updates the trade class, informing if it is allowed to trade or not, and, close position if the\\n    time passed a determined time that you set to have position opened.'}, '_supervise_updates': {'introduction': 'This class call the updates for Tick and Rates if they exist, that mean, there are NOT None!\\n\\n', 'returns': '\\n    It updates the Tick and Rates if possible.'}, 'allowed_to_trade': {'introduction': 'This function return the information if your algotrading is allowed to trade or not, it is controled by the\\nmanager class.\\n\\n', 'returns': '\\n    It returns True or False, True if your algotrading is allowed to trade or False if not.\\n\\n', 'raises': '\\n    ClassNotInvoked():\\n        The error occur when it tries tro return the trade._trade_allowed information before the trade\\n        be invoked, call the get_trade() first.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> # The Trade class need to be invoked to test the allowed_to_trade(), if it was not done, an error will\\n    >>> # occur\\n    >>> manager.allowed_to_trade()\\n    easyT.manager.ClassNotInvoked\\n    >>> manager.get_trade(symbol=symbol, lot=0.01, stop_loss=0.00, take_profit=0.00)\\n    <binanceSpotEasyT.trade.Trade object>\\n    >>> manager.allowed_to_trade()\\n    False\"}, 'get_initialize': {'introduction': 'This function will use the platform attribute to return the correct class between the options in the Class\\nPlatforms.\\n\\n', 'returns': '\\n    It returns the class already invoked.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> manager.get_initialize()\\n    <binanceSpotEasyT.initialization.Initialize object>\"}, 'get_rates': {'introduction': 'This function will use the platform attribute to return the correct class between the options in the Class\\nPlatforms.\\n\\n', 'args': {'symbol': {'description': '\\n        The symbol you want to retrieve previous data.\\n\\n    timeframe (TimeFrame):\\n        The timeframe you want information, like 1 minute, 5 minute, 1 week.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'count': {'description': '\\n        It is the amount of information in the past you want. If your time frame is 5 minutes and your count is 4,\\n        it will return 4 values containing time, open, high, low, close, tick_volume information of this past 4\\n        candlesticks.\\n\\n', 'type': <class 'int'>, 'default': 'No default argument'}}, 'returns': '\\n    It returns the class already invoked.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> manager.get_initialize()\\n    <binanceSpotEasyT.initialization.Initialize object>\\n    >>> manager.get_rates(symbol=symbol, count=20, timeframe='1m')\\n    <binanceSpotEasyT.rates.Rates object>\"}, 'get_tick': {'introduction': 'This function will use the platform attribute to return the correct class between the options in the Class\\nPlatforms.\\n\\n', 'args': {'symbol': {'description': '\\n        It is the symbol you want information about. You can have information about time, bid, ask, last, volume.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It returns the class already invoked.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> manager.get_initialize()\\n    <binanceSpotEasyT.initialization.Initialize object>\\n    >>> manager.get_tick(symbol=symbol)\\n    <binanceSpotEasyT.tick.Tick object>\"}, 'get_timeframe': {'introduction': 'This function will use the platform attribute to return the correct class between the options in the Class\\nPlatforms.\\n\\n', 'returns': '\\n    It returns the class already invoked.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> manager.get_initialize()\\n    <binanceSpotEasyT.initialization.Initialize object>\\n    >>> manager.get_timeframe()\\n    <binanceSpotEasyT.timeframe.TimeFrame object>\"}, 'get_trade': {'introduction': 'This function will use the platform attribute to return the correct class between the options in the Class\\nPlatforms.\\n\\n', 'args': {}, 'returns': '\\n    It returns the class already invoked.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\\n    >>> manager.get_initialize()\\n    <binanceSpotEasyT.initialization.Initialize object>\\n    >>> manager.get_trade(symbol=symbol, lot=0.01, stop_loss=0.00, take_profit=0.00)\\n    <binanceSpotEasyT.trade.Trade object>\"}, 'set_platform': {'introduction': 'This function is used to set the platform to the manager, the platform will be used for many functions\\nto know witch class to return and more.\\n\\n', 'args': {'platform': {'description': '\\n        It can be of type Platforms, or it can be a string. It is up to you to decide. The class Platform was\\n        created to reduce the errors possibilities when writing the correct name of the platform.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n     It returns None, but it saves the platform in an attribute.\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_platform('binance-spot')\\n    'binance-spot'\"}, 'set_trading_time': {'introduction': 'This function is responsible to set the trading time, when the time is in between the start and stop,\\ntrade is alowed, when in between in stop and position close, it is allowed to have a position opened, but it can\\nnot open a new one anymore.\\n\\nAfter the position close, it closes the position.\\n\\nPlease, pay attention to the string time format, it uses a 24h format.\\n\\n', 'args': {'time_trade_start': {'description': '\\n        The time that the algotrading can starts to trade.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'time_trade_stop': {'description': '\\n        The time that the algotrading stops to open position.\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'time_position_close': {'description': '\\n        The time the algotrading closes opened position.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    It updates the atributes in constructors, returns None\\n\\n', 'examples': \"\\n\\n    >>> from easyT.manager import Manager\\n    >>> symbol = 'BTCUSDT'\\n    >>> manager = Manager()\\n    >>> manager.set_trading_time(time_trade_start='09:00', time_trade_stop='17:30', time_position_close='17:45')\"}, 'supervise': {'introduction': \"These functions should be calling inside the while True looping, it is responsible to updates information like\\n if the AlgoTrading is allowed to trade, if it needs to close the position, and to update the tick\\n and the rates' information.\\n\\n \", 'returns': '\\n     It updates attribute values.\\n\\n', 'examples': \"\\n\\n     >>> from easyT.manager import Manager\\n     >>> symbol = 'BTCUSDT'\\n     >>> manager = Manager()\\n     >>> manager.set_platform('binance-spot')\\n     'binance-spot'\\n     >>> manager.get_initialize()\\n     <binanceSpotEasyT.initialization.Initialize object>\\n     >>> # It is important to know that supervise needs the time set.\\n     >>> manager.supervise()\\n     TypeError: '<=' not supported between instances of 'datetime.datetime' and 'NoneType'\\n     >>> manager.set_trading_time(time_trade_start='09:00', time_trade_stop='17:30', time_position_close='17:45')\\n     >>> # It is important to know that it do not only need the trading time, but also, it needs the Tick() class\\n     >>> # to retrieve the time!\\n     >>> manager.get_tick(symbol=symbol)\\n     <binanceSpotEasyT.tick.Tick object>\\n     >>> manager.supervise()\"}}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'datetime': {'introduction': 'datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])\\n\\nThe year, month and day arguments are required. tzinfo may be None, or an\\ninstance of a tzinfo subclass. The remaining arguments may be ints.'}, 'get_initialize': {'introduction': 'This function return the class that ensure the platform are working properly.\\n\\nIf it is connected on the internet, and if the symbol that you are trying to use exists or was not mistyped.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'platform': {'description': '\\n        It is the platform that the information will be returned.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}, 'get_rates': {'introduction': 'The function get_rates is used to select which rates will be used taking in consideration the platform.\\n\\nThe Rates class is responsible to retrieve a certain amount of previous data.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'platform': {'description': '\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        The symbol you want to retrieve previous data.\\n\\n    timeframe (TimeFrame):\\n        The timeframe you want information, like 1 minute, 5 minute, 1 week.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'count': {'description': '\\n        It is the amount of information in the past you want. If your time frame is 5 minutes and your count is 4,\\n        it will return 4 values containing time, open, high, low, close, tick_volume information of this past 4\\n        candlesticks.\\n\\n', 'type': <class 'int'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n        It returns the right class that will be used or an error message in case it was not found'}, 'get_tick': {'introduction': 'This function return the class that responsible to retrieve every tick information.\\n\\nTick class is the responsible to retrieve every tick information.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n     It is the symbol you want information about. You can have information about time, bid, ask, last, volume.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}, 'get_timeframe': {'introduction': 'This function return the class that responsible to hold the timeframe from different platform in a same structure.\\n\\nThere are incompatibilities and different patterns in writing the timeframe between platforms.\\nThis class attend to reduce the chance of errors providing the same timeframe structure between platforms.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found\\n\\n', 'examples': '\\n    You can find an example of the TimeFrame usage in update_rates() function in Rates documentation'}, 'get_trade': {'introduction': 'This function return the class that responsible is responsible to handle all the trade requests\\n\\nIt is allowed to have only one position at time per symbol, right now it is not possible to open a position and\\nincrease the size of it or to open opposite position. Open an open position will close the other direction one.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        It is the symbol you want to open or close or check if already have an operation opened.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'lot': {'description': '\\n        It is how many shares you want to trade, many symbols allow fractions and others requires a\\n        certain amount. It can be 0.01, 100.0, 1000.0, 10000.0.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'stop_loss': {'description': '\\n        It is how much you accept to lose. Example: If you buy a share for US$10.00, and you accept to lose US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$9.00 (sometimes more, somtime less,\\n        the US$9.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'take_profit': {'description': '\\n        It is how much you accept to win. Example: If you buy a share for US$10.00, and you accept to win US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$11.00 (sometimes more, somtime less,\\n        the US$11.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.\\n\\n', 'type': <class 'float'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}, 'parse': {'introduction': 'Parse a string in one of the supported formats, using the\\n``parserinfo`` parameters.\\n\\n:param timestr:\\n    A string containing a date/time stamp.\\n\\n:param parserinfo:\\n    A :class:`parserinfo` object containing parameters for the parser.\\n    If ``None``, the default arguments to the :class:`parserinfo`\\n    constructor are used.\\n\\nThe ``**kwargs`` parameter takes the following keyword arguments:\\n\\n:param default:\\n    The default datetime object, if this is a datetime object and not\\n    ``None``, elements specified in ``timestr`` replace elements in the\\n    default object.\\n\\n:param ignoretz:\\n    If set ``True``, time zones in parsed strings are ignored and a naive\\n    :class:`datetime` object is returned.\\n\\n:param tzinfos:\\n    Additional time zone names / aliases which may be present in the\\n    string. This argument maps time zone names (and optionally offsets\\n    from those time zones) to time zones. This parameter can be a\\n    dictionary with timezone aliases mapping time zone names to time\\n    zones or a function taking two parameters (``tzname`` and\\n    ``tzoffset``) and returning a time zone.\\n\\n    The timezones to which the names are mapped can be an integer\\n    offset from UTC in seconds or a :class:`tzinfo` object.\\n\\n    .. doctest::\\n       :options: +NORMALIZE_WHITESPACE\\n\\n        >>> from dateutil.parser import parse\\n        >>> from dateutil.tz import gettz\\n        >>> tzinfos = {\"BRST\": -7200, \"CST\": gettz(\"America/Chicago\")}\\n        >>> parse(\"2012-01-19 17:21:00 BRST\", tzinfos=tzinfos)\\n        datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u\\'BRST\\', -7200))\\n        >>> parse(\"2012-01-19 17:21:00 CST\", tzinfos=tzinfos)\\n        datetime.datetime(2012, 1, 19, 17, 21,\\n                          tzinfo=tzfile(\\'/usr/share/zoneinfo/America/Chicago\\'))\\n\\n    This parameter is ignored if ``ignoretz`` is set.\\n\\n:param dayfirst:\\n    Whether to interpret the first value in an ambiguous 3-integer date\\n    (e.g. 01/05/09) as the day (``True``) or month (``False``). If\\n    ``yearfirst`` is set to ``True``, this distinguishes between YDM and\\n    YMD. If set to ``None``, this value is retrieved from the current\\n    :class:`parserinfo` object (which itself defaults to ``False``).\\n\\n:param yearfirst:\\n    Whether to interpret the first value in an ambiguous 3-integer date\\n    (e.g. 01/05/09) as the year. If ``True``, the first number is taken to\\n    be the year, otherwise the last number is taken to be the year. If\\n    this is set to ``None``, the value is retrieved from the current\\n    :class:`parserinfo` object (which itself defaults to ``False``).\\n\\n:param fuzzy:\\n    Whether to allow fuzzy parsing, allowing for string like \"Today is\\n    January 1, 2047 at 8:21:00AM\".\\n\\n:param fuzzy_with_tokens:\\n    If ``True``, ``fuzzy`` is automatically set to True, and the parser\\n    will return a tuple where the first element is the parsed\\n    :class:`datetime.datetime` datetimestamp and the second element is\\n    a tuple containing the portions of the string which were ignored:\\n\\n    .. doctest::\\n\\n        >>> from dateutil.parser import parse\\n        >>> parse(\"Today is January 1, 2047 at 8:21:00AM\", fuzzy_with_tokens=True)\\n        (datetime.datetime(2047, 1, 1, 8, 21), (u\\'Today is \\', u\\' \\', u\\'at \\'))\\n\\n:return:\\n    Returns a :class:`datetime.datetime` object or, if the\\n    ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the\\n    first element being a :class:`datetime.datetime` object, the second\\n    a tuple containing the fuzzy tokens.\\n\\n:raises ParserError:\\n    Raised for invalid or unknown string formats, if the provided\\n    :class:`tzinfo` is not in a valid format, or if an invalid date would\\n    be created.\\n\\n:raises OverflowError:\\n    Raised if the parsed date exceeds the largest valid C integer on\\n    your system.'}}, 'initialization.py': {'type': 'python file', 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'get_initialize': {'introduction': 'This function return the class that ensure the platform are working properly.\\n\\nIf it is connected on the internet, and if the symbol that you are trying to use exists or was not mistyped.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'platform': {'description': '\\n        It is the platform that the information will be returned.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}, 'load_dotenv': {'introduction': 'Parse a .env file and then load all the variables found as environment variables.\\n\\nParameters:\\n    dotenv_path: Absolute or relative path to .env file.\\n    stream: Text stream (such as `io.StringIO`) with .env content, used if\\n        `dotenv_path` is `None`.\\n    verbose: Whether to output a warning the .env file is missing.\\n    override: Whether to override the system environment variables with the variables\\n        from the `.env` file.\\n    encoding: Encoding to be used to read the file.\\n', 'returns': '\\n    Bool: True if at least one environment variable is set else False\\n\\nIf both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the\\n.env file.'}}, 'trade.py': {'type': 'python file', 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'get_trade': {'introduction': 'This function return the class that responsible is responsible to handle all the trade requests\\n\\nIt is allowed to have only one position at time per symbol, right now it is not possible to open a position and\\nincrease the size of it or to open opposite position. Open an open position will close the other direction one.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n        It is the symbol you want to open or close or check if already have an operation opened.\\n\\n    ', 'type': <class 'str'>, 'default': 'No default argument'}, 'lot': {'description': '\\n        It is how many shares you want to trade, many symbols allow fractions and others requires a\\n        certain amount. It can be 0.01, 100.0, 1000.0, 10000.0.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'stop_loss': {'description': '\\n        It is how much you accept to lose. Example: If you buy a share for US$10.00, and you accept to lose US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$9.00 (sometimes more, somtime less,\\n        the US$9.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.\\n\\n    ', 'type': <class 'float'>, 'default': 'No default argument'}, 'take_profit': {'description': '\\n        It is how much you accept to win. Example: If you buy a share for US$10.00, and you accept to win US$1.00\\n        you set this variable at 1.00, you will be out of the operation at US$11.00 (sometimes more, somtime less,\\n        the US$11.00 is the trigger). Keep in mind that some symbols has different points metrics, US$1.00 sometimes\\n        can be 1000 points.\\n\\n', 'type': <class 'float'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}, 'load_dotenv': {'introduction': 'Parse a .env file and then load all the variables found as environment variables.\\n\\nParameters:\\n    dotenv_path: Absolute or relative path to .env file.\\n    stream: Text stream (such as `io.StringIO`) with .env content, used if\\n        `dotenv_path` is `None`.\\n    verbose: Whether to output a warning the .env file is missing.\\n    override: Whether to override the system environment variables with the variables\\n        from the `.env` file.\\n    encoding: Encoding to be used to read the file.\\n', 'returns': '\\n    Bool: True if at least one environment variable is set else False\\n\\nIf both `dotenv_path` and `stream` are `None`, `find_dotenv()` is used to find the\\n.env file.'}}, 'tick.py': {'type': 'python file', 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'get_tick': {'introduction': 'This function return the class that responsible to retrieve every tick information.\\n\\nTick class is the responsible to retrieve every tick information.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n    ', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}, 'symbol': {'description': '\\n     It is the symbol you want information about. You can have information about time, bid, ask, last, volume.\\n\\n', 'type': <class 'str'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found'}}, 'timeframe.py': {'type': 'python file', 'LogManager': {'introduction': 'The LogManager helps to manage the log pattern in all the modules in the EasyT project, and keep the same structure', '__init__': {'introduction': ':param log_filename: str\\nIt holds the string name of the log file, it will be used to create the log file that will store the log.\\nThe log is overwritten everytime the script is called.'}, 'critical': {'introduction': 'Log level: 50\\n:param message: critical\\n    It receives a critical message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'debug': {'introduction': 'Log level: 10, debug\\n:param message: str\\n    It receives a debug message and stores it in the log file.\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'error': {'introduction': 'Log level: 40\\n:param message: error\\n    It receives a error message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}, 'info': {'introduction': 'Log level: 20, info\\n:param message: str\\n    It receives an info message and stores it in the log file.\\n\\n:return: None\\n    It returns None and saves the log in the log file.'}, 'warning': {'introduction': 'Log level: 30, warning\\n:param message: str\\n    It receives a warning message, print it into the console, and stores it in the log file.\\n:return: None\\n    It returns None, print it into the console, and saves the log in the log file.'}}, 'NoPlatformFound': {'introduction': 'No platform was found, ensure that there is no mistype and that the platform is right.'}, 'Platforms': {'introduction': 'This class contains all the platforms allowed in this project!', '__init__': {'introduction': 'Initialize self.  See help(type(self)) for accurate signature.'}}, 'get_timeframe': {'introduction': 'This function return the class that responsible to hold the timeframe from different platform in a same structure.\\n\\nThere are incompatibilities and different patterns in writing the timeframe between platforms.\\nThis class attend to reduce the chance of errors providing the same timeframe structure between platforms.\\n\\n', 'args': {'log': {'description': '\\n        The log receives a log handler to be able to log the information\\n\\n    platform:\\n        It is the platform that the information will be returned.\\n\\n', 'type': <class 'supportLibEasyT.log_manager.LogManager'>, 'default': 'No default argument'}}, 'returns': '\\n    The class or Error message:\\n    It returns the right class that will be used or an error message in case it was not found\\n\\n', 'examples': '\\n    You can find an example of the TimeFrame usage in update_rates() function in Rates documentation'}}, 'shelve': 'finance', 'sub-project': 'easyT'}}"
